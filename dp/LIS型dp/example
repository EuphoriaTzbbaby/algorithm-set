*********************************************************************************leetcode*********************************************************************************
枚举选哪个

300.最长递增子序列
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        n = len(nums)
        f = [1] * n 
        for i in range(n):
            for j in range(i):
                if nums[j] < nums[i]:
                    f[i] = max(f[i], f[j] + 1)
        return max(f)

300.最长递增子序列(线段树做法，有点慢)
class segtree:
    def __init__(self, a):
        self.nums = a 
        self.n = len(a)
        self.tree = [0] * (4 * self.n)
    def push_up(self, p: int):
        self.tree[p] = max(self.tree[p * 2], self.tree[p * 2 + 1])
    def update(self, p: int, pl: int, pr: int, i: int, dis: int):
        if pl == pr:
            self.tree[p] = dis 
            return 
        mid = (pl + pr) // 2 
        if i <= mid:
            self.update(p * 2 , pl, mid, i, dis) 
        else:
            self.update(p * 2 + 1, mid + 1, pr, i, dis) 
        self.push_up(p)
    def query(self, p: int, pl: int, pr: int, l: int, r: int):
        if l <= pl and pr <= r:
            return self.tree[p] 
        res = 0
        mid = (pl + pr) // 2 
        if l <= mid:
            res = self.query(p * 2, pl, mid, l, r) 
        if mid + 1 <= r:
            res = max(res, self.query(p * 2 + 1, mid + 1, pr, l, r))
        return res
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        n = len(nums)
        f = sorted(nums) 
        mp = defaultdict(int) 
        for i, x in enumerate(f):
            mp[x] = i + 1 
        for i, x in enumerate(nums):
            nums[i] = mp[x] 
        sg = segtree(nums)
        ans = 1
        for x in nums:
            if x == 1:
                sg.update(1,1,n,1,1)
            else:
                res = 1 + sg.query(1, 1, n, 1, x-1)
                sg.update(1, 1, n, x, res)
        return sg.tree[1]

646.最长数对链
class Solution:
    def findLongestChain(self, pairs: List[List[int]]) -> int:
        pairs.sort()
        n = len(pairs)
        f = [1] * n 
        for i in range(n):
            for j in range(n):
                if pairs[j][1] < pairs[i][0]:
                    f[i] = max(f[i], f[j] + 1)
        return max(f)

139.单词拆分(枚举当前子串结束位置)
class Solution:
    def wordBreak(self, s: str, wordDict: List[str]) -> bool:
        vis = set(wordDict)
        @cache 
        def dfs(i: int):
            if i < 0:
                return True 
            res = False
            for j in range(i, -1, -1):
                if s[j : i + 1] in vis:
                    res = (res or dfs(j - 1))
            return res 
        return dfs(len(s) - 1)

377.组合总数IV
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        @cache 
        def dfs(c: int):
            if c <= 0:
                return 1 if c == 0 else 0
            return sum(dfs(c - x) for x in nums)
        return dfs(target)
