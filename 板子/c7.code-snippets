{
	"Segtree Class": {
		"scope": "cpp",
		"prefix": "seg",
		"body": [
			"struct node {",
			"    ll s, tag, ok;",
			"    node() {",
			"        s = 0;",
			"        tag = 0;",
			"        ok = 0;",
			"    }",
			"};",
			"class Segtree {",
			"public:",
			"    vector<node> tree;",
			"    vector<ll> nums;",
			"    ll n;",
			"    ll mod;",
			"    Segtree(vector<ll> &nums, ll mod) {",
			"        n = nums.size() - 1;",
			"        this->nums = nums;",
			"        this->mod = mod;",
			"        tree.resize(4 * n + 9);",
			"        build(1, 1, n);",
			"    }",
			"    void op(node &v, node v1, node v2) {",
			"        v.s = (v1.s + v2.s) % mod;",
			"    }",
			"    void build(ll p, ll pl, ll pr) {",
			"        if (pl == pr) {",
			"            tree[p].s = nums[pl] % mod;",
			"            return;",
			"        }",
			"        ll mid = (pl + pr) / 2;",
			"        build(p + p, pl, mid);",
			"        build(p + p + 1, mid + 1, pr);",
			"        op(tree[p], tree[p + p], tree[p + p + 1]);",
			"    }",
			"    void addTag(ll p, ll pl, ll pr, ll val) {",
			"        tree[p].s = (tree[p].s + (pr - pl + 1) * val % mod) % mod;",
			"        tree[p].tag = (tree[p].tag + val) % mod;",
			"        tree[p].ok = 1;",
			"    }",
			"    void pushDown(ll p, ll pl, ll pr) {",
			"        if (tree[p].ok) {",
			"            ll mid = (pl + pr) / 2;",
			"            addTag(p + p, pl, mid, tree[p].tag);",
			"            addTag(p + p + 1, mid + 1, pr, tree[p].tag);",
			"            tree[p].ok = 0;",
			"            tree[p].tag = 0;",
			"        }",
			"    }",
			"    node query(ll p, ll pl, ll pr, ll l, ll r) {",
			"        if (l <= pl && pr <= r) {",
			"            return tree[p];",
			"        }",
			"        pushDown(p, pl, pr);",
			"        ll mid = (pl + pr) / 2;",
			"        node v;",
			"        ll ok = 0;",
			"        if (l <= mid) {",
			"            ok = 1;",
			"            v = query(p + p, pl, mid, l, r);",
			"        }",
			"        if (mid + 1 <= r) {",
			"            if (ok) {",
			"                op(v, v, query(p + p + 1, mid + 1, pr, l, r));",
			"            } else {",
			"                v = query(p + p + 1, mid + 1, pr, l, r);",
			"            }",
			"        }",
			"        return v;",
			"    }",
			"    void update(ll p, ll pl, ll pr, ll l, ll r, ll val) {",
			"        if (l <= pl && pr <= r) {",
			"            addTag(p, pl, pr, val);",
			"            return;",
			"        }",
			"        pushDown(p, pl, pr);",
			"        ll mid = (pl + pr) / 2;",
			"        if (l <= mid) {",
			"            update(p + p, pl, mid, l, r, val);",
			"        }",
			"        if (mid + 1 <= r) {",
			"            update(p + p + 1, mid + 1, pr, l, r, val);",
			"        }",
			"        op(tree[p], tree[p + p], tree[p + p + 1]);",
			"    }",
			"};"
		],
		"description": "Segment Tree class for range sum queries and updates with lazy propagation"
	}
}